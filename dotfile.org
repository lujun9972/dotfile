#+TITLE: dotfile
#+AUTHOR: lujun9972
#+CATEGORY: dotfile
#+DATE: [2016-10-20 四 08:08]
#+OPTIONS: ^:{}
#+PROPERTY: header-args :comments link :tangle-mode (identity #o444) :mkdirp yes

* 窗口管理器配置
** AwesomeWM
:PROPERTIES:
:tangle:  ~/.config/awesome/rc.lua
:END:
#+BEGIN_SRC lua
  -- Standard awesome library
  local gears = require("gears")
  local awful = require("awful")
  require("awful.autofocus")
  -- Widget and layout library
  local wibox = require("wibox")
  -- Theme handling library
  local beautiful = require("beautiful")
  -- Notification library
  local naughty = require("naughty")
  local menubar = require("menubar")
  local hotkeys_popup = require("awful.hotkeys_popup").widget

  function file_exist_p (file)
    local f = io.open(file)
    if f ~= nil then
      io.close(f)
      return true
    else
      return false
    end
  end

  -- {{{ Error handling
  -- Check if awesome encountered an error during startup and fell back to
  -- another config (This code will only ever execute for the fallback config)
  if awesome.startup_errors then
      naughty.notify({ preset = naughty.config.presets.critical,
                       title = "Oops, there were errors during startup!",
                       text = awesome.startup_errors })
  end

  -- Handle runtime errors after startup
  do
      local in_error = false
      awesome.connect_signal("debug::error", function (err)
          -- Make sure we don't go into an endless error loop
          if in_error then return end
          in_error = true

          naughty.notify({ preset = naughty.config.presets.critical,
                           title = "Oops, an error happened!",
                           text = tostring(err) })
          in_error = false
      end)
  end
  -- }}}

  -- {{{ Variable definitions
  -- Themes define colours, icons, font and wallpapers.
  -- beautiful.init(awful.util.get_themes_dir() .. "default/theme.lua")
  beautiful.init("~/.config/awesome/theme.lua")

  -- This is used later as the default terminal and editor to run.
  terminal = "xterm"
  editor = os.getenv("EDITOR") or "vi"
  editor_cmd = terminal .. " -e " .. editor
  emacsclient_newframe = "emacsclient -a \"\" -n -c "

  -- Default modkey.
  -- Usually, Mod4 is the key with a logo between Control and Alt.
  -- If you do not like this or do not have such a key,
  -- I suggest you to remap Mod4 to another key using xmodmap or other tools.
  -- However, you can use another modifier like Mod1, but it may interact with others.
  modkey = "Mod4"

  -- Table of layouts to cover with awful.layout.inc, order matters.
  awful.layout.layouts = {
      awful.layout.suit.floating,
      awful.layout.suit.tile,
      awful.layout.suit.tile.left,
      awful.layout.suit.tile.bottom,
      awful.layout.suit.tile.top,
      awful.layout.suit.fair,
      awful.layout.suit.fair.horizontal,
      awful.layout.suit.spiral,
      awful.layout.suit.spiral.dwindle,
      awful.layout.suit.max,
      awful.layout.suit.max.fullscreen,
      awful.layout.suit.magnifier,
      awful.layout.suit.corner.nw,
      -- awful.layout.suit.corner.ne,
      -- awful.layout.suit.corner.sw,
      -- awful.layout.suit.corner.se,
  }
  -- }}}

  -- {{{ Helper functions
  local function client_menu_toggle_fn()
      local instance = nil

      return function ()
          if instance and instance.wibox.visible then
              instance:hide()
              instance = nil
          else
              instance = awful.menu.clients({ theme = { width = 250 } })
          end
      end
  end
  -- }}}

  -- {{{ Menu
  -- Create a launcher widget and a main menu
  myawesomemenu = {
     { "hotkeys", function() return false, hotkeys_popup.show_help end},
     { "manual", emacsclient_newframe .. " -e '(man \"awesome\")'" },
     { "重建菜单", function ()
         os.execute("xdg_menu --format awesome --root-menu /etc/xdg/menus/arch-applications.menu >~/.config/awesome/archmenu.lua" )
         awesome.restart()
     end},
     -- { "edit config", emacsclient_newframe .. awesome.conffile },
     { "edit config", emacsclient_newframe .. "~/github/dotfile/dotfile.org" },
     -- { "manual", terminal .. " -e man awesome" },
     -- { "edit config", editor_cmd .. " " .. awesome.conffile },
     { "restart", awesome.restart },
     { "quit", function() awesome.quit() end}
  }

  -- 自动生成的xdg_menu
  xdg_menu = require("archmenu")

  mymainmenu = awful.menu({ items = { { "awesome", myawesomemenu, beautiful.awesome_icon },
                              { "Applications", xdgmenu },
                              { "Eshell", "eshell.sh"},
                              { "dired", "dired.sh" },
                              { "Firefox", "firefox" },
                              { "open terminal", terminal }
  }
                          })

  mylauncher = awful.widget.launcher({ image = beautiful.awesome_icon,
                                       menu = mymainmenu })

  -- Menubar configuration
  menubar.utils.terminal = terminal -- Set the terminal for applications that require it
  -- }}}

  -- Keyboard map indicator and switcher
  mykeyboardlayout = awful.widget.keyboardlayout()

  -- {{{ Wibar
  -- Create a textclock widget
  mytextclock = wibox.widget.textclock()

  -- Create a wibox for each screen and add it
  local taglist_buttons = awful.util.table.join(
                      awful.button({ }, 1, function(t) t:view_only() end),
                      awful.button({ modkey }, 1, function(t)
                                                if client.focus then
                                                    client.focus:move_to_tag(t)
                                                end
                                            end),
                      awful.button({ }, 3, awful.tag.viewtoggle),
                      awful.button({ modkey }, 3, function(t)
                                                if client.focus then
                                                    client.focus:toggle_tag(t)
                                                end
                                            end),
                      awful.button({ }, 4, function(t) awful.tag.viewnext(t.screen) end),
                      awful.button({ }, 5, function(t) awful.tag.viewprev(t.screen) end)
                  )

  local tasklist_buttons = awful.util.table.join(
                       awful.button({ }, 1, function (c)
                                                if c == client.focus then
                                                    c.minimized = true
                                                else
                                                    -- Without this, the following
                                                    -- :isvisible() makes no sense
                                                    c.minimized = false
                                                    if not c:isvisible() and c.first_tag then
                                                        c.first_tag:view_only()
                                                    end
                                                    -- This will also un-minimize
                                                    -- the client, if needed
                                                    client.focus = c
                                                    c:raise()
                                                end
                                            end),
                       awful.button({ }, 3, client_menu_toggle_fn()),
                       awful.button({ }, 4, function ()
                                                awful.client.focus.byidx(1)
                                            end),
                       awful.button({ }, 5, function ()
                                                awful.client.focus.byidx(-1)
                                            end))

  local function set_wallpaper(s)
      -- Wallpaper
      if beautiful.wallpaper then
          local wallpaper = beautiful.wallpaper
          -- If wallpaper is a function, call it with the screen
          if type(wallpaper) == "function" then
              wallpaper = wallpaper(s)
          end
          gears.wallpaper.maximized(wallpaper, s, true)
      end
  end

  -- Re-set wallpaper when a screen's geometry changes (e.g. different resolution)
  screen.connect_signal("property::geometry", set_wallpaper)

  awful.screen.connect_for_each_screen(function(s)
      -- Wallpaper
      set_wallpaper(s)

      -- Each screen has its own tag table.
      awful.tag({ "1", "2", "3", "4", "5", "6", "7", "8", "9" }, s, awful.layout.layouts[1])

      -- Create a promptbox for each screen
      s.mypromptbox = awful.widget.prompt()
      -- Create an imagebox widget which will contains an icon indicating which layout we're using.
      -- We need one layoutbox per screen.
      s.mylayoutbox = awful.widget.layoutbox(s)
      s.mylayoutbox:buttons(awful.util.table.join(
                             awful.button({ }, 1, function () awful.layout.inc( 1) end),
                             awful.button({ }, 3, function () awful.layout.inc(-1) end),
                             awful.button({ }, 4, function () awful.layout.inc( 1) end),
                             awful.button({ }, 5, function () awful.layout.inc(-1) end)))
      -- Create a taglist widget
      s.mytaglist = awful.widget.taglist(s, awful.widget.taglist.filter.all, taglist_buttons)

      -- Create a tasklist widget
      s.mytasklist = awful.widget.tasklist(s, awful.widget.tasklist.filter.currenttags, tasklist_buttons)

      -- Create the wibox
      s.mywibox = awful.wibar({ position = "top", screen = s })

      -- Add widgets to the wibox
      s.mywibox:setup {
          layout = wibox.layout.align.horizontal,
          { -- Left widgets
              layout = wibox.layout.fixed.horizontal,
              mylauncher,
              s.mytaglist,
              s.mypromptbox,
          },
          s.mytasklist, -- Middle widget
          { -- Right widgets
              layout = wibox.layout.fixed.horizontal,
              mykeyboardlayout,
              wibox.widget.systray(),
              mytextclock,
              s.mylayoutbox,
          },
      }
  end)
  -- }}}

  -- {{{ Mouse bindings
  root.buttons(awful.util.table.join(
      awful.button({ }, 3, function () mymainmenu:toggle() end),
      awful.button({ }, 4, awful.tag.viewnext),
      awful.button({ }, 5, awful.tag.viewprev)
  ))
  -- }}}

  -- {{{ Key bindings
  globalkeys = awful.util.table.join(
      awful.key({ modkey,           }, "s",      hotkeys_popup.show_help,
                {description="show help", group="awesome"}),
      awful.key({ modkey,           }, "Left",   awful.tag.viewprev,
                {description = "view previous", group = "tag"}),
      awful.key({ modkey,           }, "Right",  awful.tag.viewnext,
                {description = "view next", group = "tag"}),
      awful.key({ modkey,           }, "Escape", awful.tag.history.restore,
                {description = "go back", group = "tag"}),

      awful.key({ modkey,           }, "j",
          function ()
              awful.client.focus.byidx( 1)
          end,
          {description = "focus next by index", group = "client"}
      ),
      awful.key({ modkey,           }, "k",
          function ()
              awful.client.focus.byidx(-1)
          end,
          {description = "focus previous by index", group = "client"}
      ),
      awful.key({ modkey,           }, "w", function () mymainmenu:show() end,
                {description = "show main menu", group = "awesome"}),

      -- Layout manipulation
      awful.key({ modkey, "Shift"   }, "j", function () awful.client.swap.byidx(  1)    end,
                {description = "swap with next client by index", group = "client"}),
      awful.key({ modkey, "Shift"   }, "k", function () awful.client.swap.byidx( -1)    end,
                {description = "swap with previous client by index", group = "client"}),
      awful.key({ modkey, "Control" }, "j", function () awful.screen.focus_relative( 1) end,
                {description = "focus the next screen", group = "screen"}),
      awful.key({ modkey, "Control" }, "k", function () awful.screen.focus_relative(-1) end,
                {description = "focus the previous screen", group = "screen"}),
      awful.key({ modkey,           }, "u", awful.client.urgent.jumpto,
                {description = "jump to urgent client", group = "client"}),
      awful.key({ modkey,           }, "Tab",
          function ()
              awful.client.focus.history.previous()
              if client.focus then
                  client.focus:raise()
              end
          end,
          {description = "go back", group = "client"}),

      -- Standard program
      awful.key({ modkey,           }, "Return", function () awful.spawn(terminal) end,
                {description = "open a terminal", group = "launcher"}),
      awful.key({ modkey, "Control" }, "r", awesome.restart,
                {description = "reload awesome", group = "awesome"}),
      awful.key({ modkey, "Shift"   }, "q", awesome.quit,
                {description = "quit awesome", group = "awesome"}),

      awful.key({ modkey,           }, "l",     function () awful.tag.incmwfact( 0.05)          end,
                {description = "increase master width factor", group = "layout"}),
      awful.key({ modkey,           }, "h",     function () awful.tag.incmwfact(-0.05)          end,
                {description = "decrease master width factor", group = "layout"}),
      awful.key({ modkey, "Shift"   }, "h",     function () awful.tag.incnmaster( 1, nil, true) end,
                {description = "increase the number of master clients", group = "layout"}),
      awful.key({ modkey, "Shift"   }, "l",     function () awful.tag.incnmaster(-1, nil, true) end,
                {description = "decrease the number of master clients", group = "layout"}),
      awful.key({ modkey, "Control" }, "h",     function () awful.tag.incncol( 1, nil, true)    end,
                {description = "increase the number of columns", group = "layout"}),
      awful.key({ modkey, "Control" }, "l",     function () awful.tag.incncol(-1, nil, true)    end,
                {description = "decrease the number of columns", group = "layout"}),
      awful.key({ modkey,           }, "space", function () awful.layout.inc( 1)                end,
                {description = "select next", group = "layout"}),
      awful.key({ modkey, "Shift"   }, "space", function () awful.layout.inc(-1)                end,
                {description = "select previous", group = "layout"}),

      awful.key({ modkey, "Control" }, "n",
                function ()
                    local c = awful.client.restore()
                    -- Focus restored client
                    if c then
                        client.focus = c
                        c:raise()
                    end
                end,
                {description = "restore minimized", group = "client"}),

      -- Prompt
      awful.key({ modkey },            "r",     function () awful.screen.focused().mypromptbox:run() end,
                {description = "run prompt", group = "launcher"}),

      awful.key({ modkey }, "x",
                function ()
                    awful.prompt.run {
                      prompt       = "Run Lua code: ",
                      textbox      = awful.screen.focused().mypromptbox.widget,
                      exe_callback = awful.util.eval,
                      history_path = awful.util.get_cache_dir() .. "/history_eval"
                    }
                end,
                {description = "lua execute prompt", group = "awesome"}),
      -- Menubar
      awful.key({ modkey }, "p", function() menubar.show() end,
                {description = "show the menubar", group = "launcher"})
  )

  clientkeys = awful.util.table.join(
      awful.key({ modkey,           }, "f",
          function (c)
              c.fullscreen = not c.fullscreen
              c:raise()
          end,
          {description = "toggle fullscreen", group = "client"}),
      awful.key({ modkey, "Shift"   }, "c",      function (c) c:kill()                         end,
                {description = "close", group = "client"}),
      awful.key({ modkey, "Control" }, "space",  awful.client.floating.toggle                     ,
                {description = "toggle floating", group = "client"}),
      awful.key({ modkey, "Control" }, "Return", function (c) c:swap(awful.client.getmaster()) end,
                {description = "move to master", group = "client"}),
      awful.key({ modkey,           }, "o",      function (c) c:move_to_screen()               end,
                {description = "move to screen", group = "client"}),
      awful.key({ modkey,           }, "t",      function (c) c.ontop = not c.ontop            end,
                {description = "toggle keep on top", group = "client"}),
      awful.key({ modkey,           }, "n",
          function (c)
              -- The client currently has the input focus, so it cannot be
              -- minimized, since minimized clients can't have the focus.
              c.minimized = true
          end ,
          {description = "minimize", group = "client"}),
      awful.key({ modkey,           }, "m",
          function (c)
              c.maximized = not c.maximized
              c:raise()
          end ,
          {description = "maximize", group = "client"})
  )

  -- Bind all key numbers to tags.
  -- Be careful: we use keycodes to make it works on any keyboard layout.
  -- This should map on the top row of your keyboard, usually 1 to 9.
  for i = 1, 9 do
      globalkeys = awful.util.table.join(globalkeys,
          -- View tag only.
          awful.key({ modkey }, "#" .. i + 9,
                    function ()
                          local screen = awful.screen.focused()
                          local tag = screen.tags[i]
                          if tag then
                             tag:view_only()
                          end
                    end,
                    {description = "view tag #"..i, group = "tag"}),
          -- Toggle tag display.
          awful.key({ modkey, "Control" }, "#" .. i + 9,
                    function ()
                        local screen = awful.screen.focused()
                        local tag = screen.tags[i]
                        if tag then
                           awful.tag.viewtoggle(tag)
                        end
                    end,
                    {description = "toggle tag #" .. i, group = "tag"}),
          -- Move client to tag.
          awful.key({ modkey, "Shift" }, "#" .. i + 9,
                    function ()
                        if client.focus then
                            local tag = client.focus.screen.tags[i]
                            if tag then
                                client.focus:move_to_tag(tag)
                            end
                       end
                    end,
                    {description = "move focused client to tag #"..i, group = "tag"}),
          -- Toggle tag on focused client.
          awful.key({ modkey, "Control", "Shift" }, "#" .. i + 9,
                    function ()
                        if client.focus then
                            local tag = client.focus.screen.tags[i]
                            if tag then
                                client.focus:toggle_tag(tag)
                            end
                        end
                    end,
                    {description = "toggle focused client on tag #" .. i, group = "tag"})
      )
  end

  clientbuttons = awful.util.table.join(
      awful.button({ }, 1, function (c) client.focus = c; c:raise() end),
      awful.button({ modkey }, 1, awful.mouse.client.move),
      awful.button({ modkey }, 3, awful.mouse.client.resize))

  -- Set keys
  root.keys(globalkeys)
  -- }}}

  -- {{{ Rules
  -- Rules to apply to new clients (through the "manage" signal).
  awful.rules.rules = {
      -- All clients will match this rule.
      { rule = { },
        properties = { border_width = beautiful.border_width,
                       border_color = beautiful.border_normal,
                       focus = awful.client.focus.filter,
                       raise = true,
                       keys = clientkeys,
                       buttons = clientbuttons,
                       screen = awful.screen.preferred,
                       placement = awful.placement.no_overlap+awful.placement.no_offscreen
       }
      },
      { rule = { class = "MPlayer" },
        properties = { floating = true } },
      { rule = { class = "pinentry" },
        properties = { floating = true } },
      { rule = { class = "gimp" },
        properties = { floating = true } },
      { rule = { class = "Firefox" },
        properties = { floating = true } },
      -- Set Firefox to always map on tags number 2 of screen 1.
      -- { rule = { class = "Firefox" },
      --   properties = { tag = tags[1][2] } },

      -- Floating clients.
      { rule_any = {
          instance = {
            "DTA",  -- Firefox addon DownThemAll.
            "copyq",  -- Includes session name in class.
          },
          class = {
            "Arandr",
            "Gpick",
            "Kruler",
            "MessageWin",  -- kalarm.
            "Sxiv",
            "Wpa_gui",
            "pinentry",
            "veromix",
            "xtightvncviewer"},

          name = {
            "Event Tester",  -- xev.
          },
          role = {
            "AlarmWindow",  -- Thunderbird's calendar.
            "pop-up",       -- e.g. Google Chrome's (detached) Developer Tools.
          }
        }, properties = { floating = true }},

      -- Add titlebars to normal clients and dialogs
      { rule_any = {type = { "normal", "dialog" }
        }, properties = { titlebars_enabled = true }
      },

      -- Set Firefox to always map on the tag named "2" on screen 1.
      -- { rule = { class = "Firefox" },
      --   properties = { screen = 1, tag = "2" } },
  }
  -- }}}

  -- {{{ Signals
  -- Signal function to execute when a new client appears.
  client.connect_signal("manage", function (c)
      -- Set the windows at the slave,
      -- i.e. put it at the end of others instead of setting it master.
      -- if not awesome.startup then awful.client.setslave(c) end

      if awesome.startup and
        not c.size_hints.user_position
        and not c.size_hints.program_position then
          -- Prevent clients from being unreachable after screen count changes.
          awful.placement.no_offscreen(c)
      end
  end)

  -- Add a titlebar if titlebars_enabled is set to true in the rules.
  client.connect_signal("request::titlebars", function(c)
      -- buttons for the titlebar
      local buttons = awful.util.table.join(
          awful.button({ }, 1, function()
              client.focus = c
              c:raise()
              awful.mouse.client.move(c)
          end),
          awful.button({ }, 3, function()
              client.focus = c
              c:raise()
              awful.mouse.client.resize(c)
          end)
      )

      awful.titlebar(c) : setup {
          { -- Left
              awful.titlebar.widget.iconwidget(c),
              buttons = buttons,
              layout  = wibox.layout.fixed.horizontal
          },
          { -- Middle
              { -- Title
                  align  = "center",
                  widget = awful.titlebar.widget.titlewidget(c)
              },
              buttons = buttons,
              layout  = wibox.layout.flex.horizontal
          },
          { -- Right
              awful.titlebar.widget.floatingbutton (c),
              awful.titlebar.widget.maximizedbutton(c),
              awful.titlebar.widget.stickybutton   (c),
              awful.titlebar.widget.ontopbutton    (c),
              awful.titlebar.widget.closebutton    (c),
              layout = wibox.layout.fixed.horizontal()
          },
          layout = wibox.layout.align.horizontal
      }
  end)

  -- Enable sloppy focus, so that focus follows mouse.
  client.connect_signal("mouse::enter", function(c)
      if awful.layout.get(c.screen) ~= awful.layout.suit.magnifier
          and awful.client.focus.filter(c) then
          client.focus = c
      end
  end)

  client.connect_signal("focus", function(c) c.border_color = beautiful.border_focus end)
  client.connect_signal("unfocus", function(c) c.border_color = beautiful.border_normal end)
  -- }}}

  -- Autorun programs
  autorun = true
  autorunApps = 
    { 
      "ps -fu $(whoami)|grep \"emacs --daemon\"|grep -v grep || emacs --daemon"
    }

  if autorun then
    for app = 1, #autorunApps do
      awful.util.spawn_with_shell(autorunApps[app])
    end
  end
#+END_SRC

** Stumpwm 
:PROPERTIES:
:tangle:  ~/.stumpwmrc
:END:
#+BEGIN_SRC lisp 
  ;; vim:filetype=lisp
  (in-package :stumpwm)
  ;; 加载mode

  ;(set-contrib-dir "/usr/local/share/stumpwm")
  (mapcar #'load-module
    '("amixer"
      "cpu"
      "mem"
      "battery-portable"
      "net"
      "wifi"
      "disk"
      "app-menu"
      "stumptray"
      ;;"ttf-fonts"
      ))
  (set-prefix-key (kbd "F12"))      ;设置前缀键,已经在.xinitrc中定义Win为F12了
  ;; turn on debugging 0:disable
  (setf stumpwm::*debug-level* 0)
  ;(redirect-all-output (data-dir-file "debug-output" "txt"))

  ;(defun show-key-seq (key seq val)
  ;    (message (print-key-seq (reverse seq))))
  ;(add-hook *key-press-hook* 'show-key-seq)

  (defmacro replace-hook (hook fn)
      `(remove-hook ,hook ,fn)
      `(add-hook ,hook ,fn))

  ; If you like Meta (most probably alt on your keyboard) more than
  ; Super (which is the Windows key on mine), change 's-' into 'M-'.
  (defmacro defkey-top (key cmd)
      `(define-key *top-map* (kbd ,key) ,cmd))

  (defmacro defkeys-top (&rest keys)
      (let ((ks (mapcar #'(lambda (k) (cons 'defkey-top k)) keys)))
          `(progn ,@ks)))

  (defmacro defkey-root (key cmd)
      `(define-key *root-map* (kbd ,key) ,cmd))

  (defmacro defkeys-root (&rest keys)
      (let ((ks (mapcar #'(lambda (k) (cons 'defkey-root k)) keys)))
          `(progn ,@ks)))

  (defcommand display-current-window-info () ()
    "Shows the properties of the current window. These properties can be
  used for matching windows with run-or-raise or window placement
  -merules."
    (let ((w (current-window))
          (*suppress-echo-timeout* t)
          (nl (string #\NewLine)))

      ;; (message-no-timeout "class: ~a~%instance~a~%..." (window-class w) (window-res w) ...)
      (echo-string (current-screen)
                   (concat "class:    " (window-class w) nl
                           "instance: " (window-res w) nl
                           "type:     :" (string (window-type w)) nl
                           "role:     " (window-role w) nl
                           "title:    " (window-title w) nl
                           "width:    " (format nil "~a" (window-width w)) nl
                           "height    " (format nil "~a" (window-height w))))))

  ; 任何时候按下<s-c>就可以查单词， 非常方便！
  (defcommand dict (word) ((:rest "Word> "))
    (let ((cmd (format nil "dict ~a" word)))
      (with-output-to-string (*standard-output*)
       ,#+clisp(let ((str (ext:run-shell-command cmd :output :stream :wait nil)))
         (loop for line = (read-line str nil)
            until (null line)
            do (print line)))
       ,#+sbcl (sb-ext:run-program "/bin/sh" (list "-c" cmd) :input nil :output *standard-output*)
       ,#+ccl(ccl:run-program "/bin/sh" (list "-c" cmd) :input nil :output *standard-output*))))
  (set-fg-color "green")
  (set-bg-color "black")

  ;; 3.  安装字体： xfont-unifont
  ;;     这个字体是等宽字体，虽然中英文不能完全对齐，但显示效果很好，
  ;;     类似winxp。
  (set-font "*-unifont-medium-*-normal-*-16-*-*-*-*-*-*-*")
  ;; (set-font "-*-unifont-medium-i-normal-*-16-*-*-*-*-*-*-*")
  ;; suppress the message StumpWM displays when it starts. Set it to NIL
  (setf *startup-message* nil
        ,*suppress-frame-indicator* t
        ,*suppress-abort-messages* t
        ,*timeout-wait* 3
        ,*mouse-focus-policy* :click ;; :click, :ignore, :sloppy
        ,*message-window-gravity* :bottom-left
        ,*input-window-gravity* :bottom-left)

  ;;; Window Appearance
  (setf *normal-border-width* 1
        ,*maxsize-border-width* 1
        ,*transient-border-width* 1
        +default-frame-outline-width+ 1
        ,*float-window-title-height* 0
        ,*window-border-style* :thin) ; :thick :thin :tight :none

  (setf *time-modeline-string* "%Y-%m-%d %a ^B%l:%M^b" 
        ,*window-name-source* :title
        ;; *window-format* "^B^8*%n%s%m%15t | ^7*"
        ,*window-format* "%n%s%m%15t | "
        ,*group-format* "%t")

  (setf *chinese-day-names*
        '("一" "二" "三" "四" "五" "六" "日"))
  (defun current-date ()
    "Returns the date formatted as `2009-11-16 一 11:34:03'."
    (multiple-value-bind
    (second minute hour date month year day-of-week dst-p tz)
        (get-decoded-time)
      (format nil "~d-~2,'0d-~2,'0d ~a ^B~2,'0d:~2,'0d:~2,'0d^b"
        year month date (nth day-of-week *chinese-day-names*)
        hour minute second)))
   ;;;; The Mode Line
  (setf *mode-line-background-color* "black"
        ,*mode-line-foreground-color* "lightgreen"
        ,*mode-line-border-color* "black"
        ,*mode-line-border-width* 0
        ,*mode-line-pad-x* 0
        ,*mode-line-pad-y* 0
        ,*mode-line-timeout* 1 
      ;; *mode-line-position* :bottom
        ;; *screen-mode-line-format* (list "[%n]%W" "^>" '(:eval (current-date)))
      ,*screen-mode-line-format* (list
                   "^6*" '(:eval (current-date)) ; defined above
                   " | %D | %c(%f,%t) | %M | %l"
                   '(:eval (run-shell-command "echo" t))
                   "^2*" "[^B%n^b] %W"))

  ;; 定义mode-line的点击
  (defun show-params (mode-line button x y)
    (let ((mode-lin-content (mode-line-contents mode-line)) (mode-line-height (mode-line-height mode-line)))
    (message "mode-line:~a,~a"  x y))
    )
  (add-hook *mode-line-click-hook* 'show-params)
  ;; turn on/off the mode line for the current screen only.
  (if (not (head-mode-line (current-head)))
       (toggle-mode-line (current-screen) (current-head)))

  ;;add hook so I get notified when people say my name on IRC or IM me
  (defun echo-urgent-window (target)
      (message-no-timeout "~a has an message for you." (window-title target)))
  (add-hook *urgent-window-hook* 'echo-urgent-window)

  ;; shell program used by `run-shell-command' (`sh' by default, which is *not* 'bash' nor 'zsh')
  (setf *shell-program* (stumpwm::getenv "SHELL"))
  ;; (clear-window-placement-rules)

  (defun random-string (length)
    "Return a random string with LENGTH characters."
    (let ((alphabet (concat
         "abcdefghijklmnopqrstuvwxyz"
         "0123456789"
         "ABCDEFGHIJKLMNOPQRSTUVWXYZ"))
    (string (make-string length)))
      (map-into string (lambda (char)
             (declare (ignore char))
             (aref alphabet (random (length alphabet))))
          string)))

  (defun my-run-or-raise (cmd props &optional (all-groups *run-or-raise-all-groups*)
              (all-screens *run-or-raise-all-screens*))
    "若程序未运行,则运行程序,否则切换到该程序"
    (let* ((group (current-group))
     (frames (when (eq (type-of group) 'tile-group)
         (group-frames group))))
      (if (> (length frames) 1)
    (run-or-pull cmd props all-groups all-screens)
    (run-or-raise cmd props all-groups all-screens))))

  (defcommand firefox () ()
    "Start Firefox or switch to it, if it is already running."
    (my-run-or-raise "iceweasel" '(:class "Iceweasel")))

  (defcommand file-manager () ()
    "Start nautilus"
    (my-run-or-raise "nautilus --no-desktop" '(:class "Nautilus")))

  (defcommand foxit () ()
    (launch-crossover-app "FoxitReader" "FoxitReader"))

  (defcommand mplayer () ()
    (my-run-or-raise "smplayer" '(:class "Smplayer")))

  (defcommand lock-screen () ()
    (run-shell-command "exec xscreensaver-command -lock"))

  (defcommand dmenu-run () ()
    (run-shell-command "$(dmenu_path | dmenu -b)"))
  ;; 定义类Emacs的快捷键
  (defvar *my-ctrl-x-keymap*
    (let ((m (stumpwm:make-sparse-keymap)))
    (stumpwm:define-key m (stumpwm:kbd "o") "fnext")
    (stumpwm:define-key m (stumpwm:kbd "C-b") "frame-windowlist")
    (stumpwm:define-key m (stumpwm:kbd "b") "pull-window-by-number")
    (stumpwm:define-key m (stumpwm:kbd "C-c") "quit")
    (stumpwm:define-key m (stumpwm:kbd "k") "delete-window")
    (stumpwm:define-key m (stumpwm:kbd "K") "kill-window")
    (stumpwm:define-key m (stumpwm:kbd "1") "only")
    (stumpwm:define-key m (stumpwm:kbd "2") "vsplit")
    (stumpwm:define-key m (stumpwm:kbd "3") "hsplit")
    m))
  (stumpwm:define-key *root-map* (stumpwm:kbd "C-x") '*my-ctrl-x-keymap*)

  ;; 定义类似awesome的快捷键
  (defkey-top "M-TAB" "other-in-frame")
  (defkey-top "s-j" "next-in-frame")
  (defkey-top "s-k" "prev-in-frame")
  (defkey-top "s-r" "dmenu-run")
  ;; (defkey-top "s-r" "run-shell-command")
  (defkey-top "s-q" "quit")
  (defkey-root "M-x" "colon")
  (defkey-top "s-RET" "exec x-terminal-emulator")
  (defkey-root "f" "file-manager")
 
  ;; 定义声音
  (define-key *top-map* (kbd "XF86AudioLowerVolume") "amixer-Front-1-")
  (define-key *top-map* (kbd "XF86AudioRaiseVolume") "amixer-Front-1+")
  (define-key *top-map* (kbd "XF86AudioMute") "amixer-Master-toggle pulse")

  ;; 定义s-Fn为切换到第n个group
  (defkey-top "s-F1" "gselect 1")
  (defkey-top "s-F2" "gselect 2")
  (defkey-top "s-F3" "gselect 3")
  (defkey-top "s-F4" "gselect 4")
  (defkey-top "s-F5" "gselect 5")

  ;; 定义s-n为切换到第n个window
  (defkey-top "s-`" "select-window-by-number 0")
  (defkey-top "s-1" "select-window-by-number 1")
  (defkey-top "s-2" "select-window-by-number 2")
  (defkey-top "s-3" "select-window-by-number 3")
  (defkey-top "s-4" "select-window-by-number 4")
  (defkey-top "s-5" "select-window-by-number 5")
  (defkey-top "s-5" "select-window-by-number 6")
  (defkey-top "s-5" "select-window-by-number 7")
  (defkey-top "s-5" "select-window-by-number 8")
  (defkey-top "s-5" "select-window-by-number 9")


  (run-commands "stumptray")
  (run-shell-command "~/.nutstore/dist/bin/nutstore-pydaemon.py")
  (run-shell-command "xset b off")
  (run-shell-command "xfce4-power-manager")
  (run-shell-command "xscreensaver -no-splash")
  (run-shell-command "nm-applet")
  (run-shell-command "volti")

#+END_SRC
* bash登陆相关配置
** bash_profile
#+BEGIN_SRC sh :tangle "~/.bash_profile"
  #
  # ~/.bash_profile
  #

  # ps -fu $(whoami)|grep "emacs --daemon"|grep -v grep || LC_ALL=zh_CN.UTF-8 emacs --daemon &

  # NO BEEP
  setterm -blength 0

  [[ -f ~/.bashrc ]] && . ~/.bashrc
  export PATH=~/bin:$PATH

  # Auto load scripts in ~/bin/autoload
  LOG_FILE=/tmp/info.log
  ERR_FILE=/tmp/error.log
  if [ -d ~/bin/autoload ];then
      for f in $(ls ~/bin/autoload)
      do
          source ~/bin/autoload/$f >>$LOG_FILE 2>>$ERR_FILE
      done
  fi

  function command_exist_p()
  {
      which $1 >/dev/null 2>/dev/null
  }

  if command_exist_p fbterm && command_exist_p fcitx-fbterm ;then
      # 启动fbterm
      fcitx-fbterm-helper -l
      # fbterm -i fcitx-fbterm
  else
      # 自动启用X，如果希望在 X 会话终止时保持登入状态，删除 exec
      [ -z "$DISPLAY" -a "$(fgconsole)" -eq 1 ] && exec startx
  fi
#+END_SRC
** bashrc
#+BEGIN_SRC sh :tangle "~/.bashrc"
  #
  # ~/.bashrc
  #
  # If not running interactively, don't do anything
  [[ $- != *i* ]] && return

  alias "vi=vim"
  alias ls='ls --color=auto'
  PS1='[\u@\h \W]\$ '
#+END_SRC
* X相关配置
** xinitrc
#+BEGIN_SRC sh :tangle "~/.xinitrc"
  # NO BEEP
  xset -b

  # setup fcitx
  export GTK_IM_MODULE=fcitx
  export QT_IM_MODULE=fcitx
  export XMODIFIERS="@im=fcitx"
  export LANG=zh_CN.UTF-8
  fcitx

  # RUN emacs --daemon
  # ps -fu $(whoami)|grep "emacs --daemon"|grep -v grep || emacs --daemon &

  # 屏幕保护程序
  # xscreensaver &

  # xmodmap -e "remove Lock = Caps_Lock"
  # xmodmap -e "keysym Caps_Lock = Super_R"
  # xmodmap -e "keysym XF86WakeUp = Super_R"
  exec awesome
#+END_SRC
** Xdefaults
#+BEGIN_SRC conf-xdefaults :tangle "~/.Xdefaults"
  XTerm*metaSendsEscape:  true
  XTerm*eightBitInput:    false

  XTerm*Font:       7x13

  xterm*faceName: DejaVu Sans Mono:style=Book:antialias=false:size=10
  xterm*faceNameDoublesize: WenQuanYi Micro Hei Mono:size=10
  xterm*faceSize: 8

  XTerm*locale: zh_CN.UTF-8
  xterm*utf8: true
  xterm*utf8Title: true

  XTerm*scrollBar:  true

  XTerm*rightScrollBar:  true

  XTerm*saveLines:  4096

  xterm*bellIsUrgent: true

  XTerm*scaleHeight: 1.01

  xterm*borderWidth: 0

#+END_SRC

* 将Caps_Ctrl换成Win键
对于X41这种不带Win键，但是awesome没有Win键是很难用的。可以按照下面步骤来将Caps_Lock换成Win键

#+BEGIN_SRC sh
  xmapmode -pke > ~/.Xmodmap
  echo "remove Lock = Caps_Lock" >> ~/.Xmodmap
  echo "keysym Caps_Lock = Super_R" >> ~/.Xmodmap
#+END_SRC
